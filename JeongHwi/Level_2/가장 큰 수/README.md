# 가장 큰 수

###### 문제 설명

0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.

예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.

0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.

##### 제한 사항

- numbers의 길이는 1 이상 100,000 이하입니다.
- numbers의 원소는 0 이상 1,000 이하입니다.
- 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.

##### 입출력 예

| numbers           | return  |
| ----------------- | ------- |
| [6, 10, 2]        | 6210    |
| [3, 30, 34, 5, 9] | 9534330 |



### Code

```python
def solution(numbers):
    numbers = [(str(x)+str(x)+str(x),y) for x,y in zip(numbers,numbers)]
    new = [str(x[1]) for x in sorted(numbers,reverse=True,key=lambda x:x[0])]
    return str(int("".join(new)))
```



### Solution

https://ryulurala.tistory.com/51 를 보고 해결하였다.

처음 접근은 `permutation`을 사용해서 접근했는데, 이는 완전탐색이 되버려서 시간초과를 야기한다. 따라서 다른 방법을 써야한다.

그리고 두번째 방법은 정렬 방식을 Heap 정렬이나 특정 정렬을 사용해야하는 것인가해서 기존 정렬의 시간복잡도를 찾아봤는데 QuickSort라 가장 빠를 것이다..

결국 힌트를 봤다..



핵심은 numbers에 있는 input 값들을 전부 `*3`을 해주는 것이다 

`12` -> `121212` 

`121` -> `121121121` 이런식으로 말이다.

왜 3이냐면 1000 이하의 숫자이기 때문이다.

`1` 인경우 1000 이하의 숫자가 되는 3자리수가 되기 위해서이다. (`111`)

이걸 사전 순으로 내림차순 정렬을 하면 

> 사전순으로 정렬이 되면 그걸 합쳤을 때 가장 큰 수가 되기 때문이다.

`121212 , 121121121` 을 비교하는데, x[0]->x[1]->x[2] 순으로 정렬을 한다. 

`return`문에 `str(int("",join(new)))` 를 해주는 이유는 `0` 때문에 예외처리를 해준 것이다.

`[0,0,0]` 인 경우 가장 큰 수는 `0` 인데 이를 `str`로 합치면 `000` 이 되기 때문에 `int`로 바꿔주고 다시 `string`으로 바꿔준 것이다.



 



 t1 = "12121"

t2 =  "12112"

인트로 바꿨을 경우

(12121 > 12112) - (12121 < 12112)



