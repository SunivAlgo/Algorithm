# 풍선터뜨리기

###### 문제 설명

일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.

1. 임의의 **인접한** 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.
2. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.

여기서 조건이 있습니다. 인접한 두 풍선 중에서 **번호가 더 작은 풍선**을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.

당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 **불가능**할 수도 있습니다.

일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.

------

##### 제한 사항

- a의 길이는 1 이상 1,000,000 이하입니다.
  - `a[i]`는 i+1 번째 풍선에 써진 숫자를 의미합니다.
  - a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.
  - a의 모든 수는 서로 다릅니다.

------

##### 입출력 예

| a                                       | result |
| --------------------------------------- | ------ |
| `[9,-1,-5]`                             | 3      |
| `[-16,27,65,-2,58,-92,-71,-68,-61,-33]` | 6      |

------

##### 입출력 예 설명

입출력 예 #1

- 첫 번째 풍선(9가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
  1. `[9, -1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.
  2. `[9, -5]` 에서 9, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.
- 두 번째 풍선(-1이 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
  1. `[9, -1, -5]` 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.
  2. `[-1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.
- 세 번째 풍선(-5가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
  1. `[9, -1, -5]` 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.
  2. `[-1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.
- 3개의 풍선이 최후까지 남을 수 있으므로, 3을 return 해야 합니다.

입출력 예 #2

- 최후까지 남을 수 있는 풍선은 -16, -92, -71, -68, -61, -33이 써진 풍선으로 모두 6개입니다.



### Code

```python
# 풀이 참고한 문제 : https://velog.io/@eehwan/프로그래머스-풍선-터트리기-파이썬 , https://kobumddaring.tistory.com/28
def solution(a):
    ans = [0 for _ in range(len(a))]
    l_M = r_M = float("inf")

    for i in range(len(a)):
        if a[i] < l_M:
            l_M = a[i]
            ans[i] = 1
        if a[-1-i] < r_M:
            r_M = a[-1-i]
            ans[-1-i] = 1
    return sum(ans)

    
print(solution([9,-1,-5]))
print(solution([-16,27,65,-2,58,-92,-71,-68,-61,-33]))
print(solution([1,2,3,4,5]))
```

### Solution

다른 사람 풀이를 참고하였음

* 양 끝, 최솟값은 무조건 살아남을 수 있다.
* 양 끝은 찬스를 하나 써서 자기보다 작은 수를 없앨 수 있기 때문에 무조건 터트릴 수 있다.

#### [-16,27,65,-2,58,-92,-71,-68,-61,-33]

2가지 경우로 나누어 보자

* 찬스가 쓰는 경우

  * #### [-92,-71,-68]

    * 이 경우에는 `-68`을 먼저 터트리고, `-92`를 찬스를 사용해서 터트린다.

* 찬스를 안써도 되는 경우 (최소값)

  * #### [-16,-92,-71]

    * 이 경우에는 `-92`가 최솟값이기 때문에 양 옆 두 풍선을 둘다 터트릴 수 있다.

* 특정 숫자가 무조건 죽는 경우

  * #### [-16,27,-2]

    * 27이 찬스를 사용해서 가장 작은 수인 `-16` 터트려도 `-2`보다 크기때문에 무조건 터진다.

여기서 규칙을 알 수 있다.

`선택된 idx가 살아남으려면 양 옆 숫자보다 작아야하거나 양 끝값 이어야한다.`



그래서 우선 -16 을 `Left Min` 으로 두고 , -33 을 `Right Min` 으로 두어서 사이에 값을 체크한다.

진행과정은 다음과 같다.

```bash
-16 / Check : 27 / -33   ==> 27 무조건 터짐
-16 / Check : 65 / -33   ==> 65 무조건 터짐
-16 / Check : -2 / -33   ==> -2 무조건 터짐
...
-16 / check : -92 / -33  ==> 터지지않음, Left Min 갱신
-92 / Check : -71 / -33  ==> 터지지않음, (-33보다 작기 때문)
-92 / Check : -68 / -33  ==> 터지지않음, (-33보다 작기 때문)
-92 / Check : -61 / -33  ==> 터지지않음, (-33보다 작기 때문)
```

Right 도 동일하게 처리





